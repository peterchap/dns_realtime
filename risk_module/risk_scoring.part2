        for c in profile.get("direct_sub_columns", []):
            if c in df.columns:
                df = df.with_columns(
                    (pl.col("__score") - pl.col(c).fill_null(0)).alias("__score")
                )

        # Clamping
        max_score = profile.get("max_score", 100)
        min_score = profile.get("min_score", 0)
        df = df.with_columns(
            pl.col("__score").clip(min_score, max_score)
        )

        # Thresholds -> risk_level
        thresholds = profile.get("thresholds", {})
        crit = thresholds.get("critical", 80)
        high = thresholds.get("high", 60)
        med = thresholds.get("medium", 30)
        
        df = df.with_columns(
            pl.when(pl.col("__score") >= crit).then(pl.lit("critical"))
            .when(pl.col("__score") >= high).then(pl.lit("high"))
            .when(pl.col("__score") >= med).then(pl.lit("medium"))
            .otherwise(pl.lit("low"))
            .alias("risk_level")
        )

        # Explainability: concat triggered rule names
        # Efficient approach: use concat_list with filtering
        # We have mask columns
        
        reason_exprs = []
        for rc in rule_cols:
            if len(rc) == 3:
                rname, points, mask_col = rc
                # format: "name(pts)"
                txt = f"{rname}({points})"
                # if mask true, return txt, else null
                reason_exprs.append(
                    pl.when(pl.col(mask_col)).then(pl.lit(txt)).otherwise(pl.lit(None))
                )
            elif len(rc) == 4:
                rname, _, mask_col, pts_col = rc
                # dynamic points
                # format: "name(pts_val)"
                # concat string
                txt_expr = pl.format("{}({})", pl.lit(rname), pl.col(pts_col))
                reason_exprs.append(
                    pl.when(pl.col(mask_col)).then(txt_expr).otherwise(pl.lit(None))
                )

        df = df.with_columns(
            pl.concat_list(reason_exprs).list.drop_nulls().alias("risk_reasons_list")
        )
        
        # Convert list to comma-joined string
        df = df.with_columns(
            pl.col("risk_reasons_list").list.join(", ").alias("risk_reasons")
        )

        # Add version
        df = df.with_columns(pl.lit(self.version).alias("score_version"))
        
        # Cleanup temp columns
        cols_to_drop = [c for c in df.columns if c.startswith("__")]
        # Keep risk_reasons_list? user wants list or json? Doc says list[str] or stringified json.
        # we provided string "name(pts), name(pts)".
        # let's drop the list obj to keep it simple arrow-compatible (strings)
        cols_to_drop.append("risk_reasons_list")
        
        df = df.drop(cols_to_drop)

        # Rename __score to risk_score
        # Wait, I did aliases logic inside. But __score is the final col name?
        # Check if I aliased it back to risk_score? No. 
        # Rename now.
        if "__score" in df.columns: # it is there
            df = df.rename({"__score": "risk_score"})
            
        return df.to_arrow()
